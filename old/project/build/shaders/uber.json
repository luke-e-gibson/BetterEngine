{"name":"uberShader","content":{"vertex":"#version 300 es\r\nprecision highp float;\r\n\r\nin vec4 aPosition;\r\nin vec3 aNormal;\r\nin vec2 aTexCoord;\r\n\r\nuniform mat4 uModelMatrix;\r\nuniform mat4 uViewMatrix;\r\nuniform mat4 uProjectionMatrix;\r\n\r\nuniform bool uUseLighting;\r\nuniform bool smoothShading;\r\nuniform bool uUseTexture;\r\n\r\nout vec3 vNormal;\r\nout vec3 vFragPosition;\r\nout vec3 vFlatNormal;\r\nout vec2 vTextureCoord;\r\n\r\nvoid main() {\r\n    vec4 worldPosition = uModelMatrix * aPosition;\r\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\r\n    \r\n    // Transform normal to world space\r\n    mat3 normalMatrix = mat3(transpose(inverse(uModelMatrix)));\r\n    vec3 worldNormal = normalMatrix * aNormal;\r\n    \r\n    // Pass both smooth and flat normals\r\n    vNormal = normalize(worldNormal);\r\n    vFlatNormal = worldNormal; // Will be flattened by flat interpolation in fragment shader\r\n    vFragPosition = vec3(worldPosition);\r\n    vTextureCoord = aTexCoord;\r\n}","fragment":"#version 300 es\r\nprecision highp float;\r\n\r\nin vec3 vNormal;\r\nin vec3 vFragPosition;\r\nin vec3 vFlatNormal;\r\nin vec2 vTextureCoord;\r\n\r\nuniform vec3 uLightPos;\r\nuniform vec4 uLightColor;\r\nuniform vec4 uModelColor;\r\nuniform sampler2D uTexture;\r\n\r\nuniform bool uUseLighting;\r\nuniform bool smoothShading;\r\nuniform bool uUseTexture;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    vec3 baseColor;\r\n    float alpha;\r\n    if(uUseTexture) {\r\n        // Sample the texture color\r\n        vec4 texColor = texture(uTexture, vTextureCoord);\r\n        baseColor = texColor.rgb;\r\n        alpha = texColor.a;\r\n        \r\n        // If the texture is fully transparent, discard the fragment\r\n        if (alpha < 0.01) {\r\n            discard;\r\n        }\r\n    }else {\r\n        baseColor = uModelColor.rgb;\r\n        alpha = uModelColor.a;\r\n    }\r\n    \r\n    // If lighting is disabled, just return the base color\r\n    if (!uUseLighting) {\r\n        fragColor = vec4(baseColor, uModelColor.a);\r\n        return;\r\n    }\r\n    \r\n    // Choose between smooth and flat shading\r\n    vec3 N;\r\n    if (smoothShading) {\r\n        // Use interpolated normal for smooth shading\r\n        N = normalize(vNormal);\r\n    } else {\r\n        // Use face normal for flat shading\r\n        // Calculate face normal using derivatives\r\n        vec3 dFdxPos = dFdx(vFragPosition);\r\n        vec3 dFdyPos = dFdy(vFragPosition);\r\n        N = normalize(cross(dFdxPos, dFdyPos));\r\n    }\r\n    \r\n    // Calculate light direction and distance\r\n    vec3 lightDiff = uLightPos - vFragPosition;\r\n    float distance = length(lightDiff);\r\n    vec3 L = normalize(lightDiff);\r\n    \r\n    // Simple Phong diffuse with ambient\r\n    float diff = max(dot(N, L), 0.0);\r\n    \r\n    // Calculate attenuation (light falloff)\r\n    // Using the inverse square law with some constants to control the falloff\r\n    float constant = 1.0;\r\n    float linear = 0.09;\r\n    float quadratic = 0.032;\r\n    float attenuation = 1.0 / (constant + linear * distance + quadratic * (distance * distance));\r\n    \r\n    vec3 ambient = 0.2 * baseColor;\r\n    vec3 diffuse = diff * baseColor * uLightColor.rgb;\r\n    \r\n    // Apply attenuation to the diffuse component (not typically to ambient)\r\n    diffuse *= attenuation;\r\n    \r\n    fragColor = vec4(ambient + diffuse, alpha);\r\n    //fragColor = vec4(baseColor, alpha);\r\n}"}}